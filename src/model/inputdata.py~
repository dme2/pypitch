from __future__ import absolute_import
from __future__ import division
from __future__ import print_function

import hashlib
import math
import os.path
import random
import re
import sys
import tarfile

import numpy as np
from six.moves import urllib
from six.moves import xrange  # pylint: disable=redefined-builtin
import tensorflow as tf

from tensorflow.contrib.framework.python.ops import audio_ops as contrib_audio
from tensorflow.python.ops import io_ops
from tensorflow.python.platform import gfile
from tensorflow.python.util import compat

MAX_NUM_WAVS_PER_CLASS = 2**27 - 1  # ~134M
SILENCE_LABEL = '_silence_'
SILENCE_INDEX = 0
UNKNOWN_WORD_LABEL = '_unknown_'
UNKNOWN_WORD_INDEX = 1
RANDOM_SEET = 59185

def prepare_chord_list(wanted_chords):
    """
    input: 
    wanted_chords - list containing chord names
     
    return:
    list with silence and unknown labels added
    """
    return [SILENCE_LABEL, UNKNOWN_CHORD_LABEL] + wanted_chords

def which_set(filename, validation_percentage, testing_percentage):
    """
    keep the files in training, validation and testing consistent
    
    input:
    filename - file path
    validation_percentage - percent of data to be used for validation
    testing_percentage - percent of data to be used for testing
    """

    base_name = os.path.basename(filename)
    #ignore anything with no_hash in the filename 
    hash_name = re.sub(r'_nohash_.*$', '' , base_name)

    hash_name_hashed = hashlib.sha1(compat.as_bytes(hash_name)).hexdigest()
    
    percentage_hash = ((int(hash_name_hashed, 16) %
                      (MAX_NUM_WAVS_PER_CLASS + 1)) *
                     (100.0 / MAX_NUM_WAVS_PER_CLASS))
    
    if percentage_hash < validation_percentage:
        result = 'validation'
    elif percentage_hash < (testing_percentage + validation_percentage):
        result = 'testing'
    else:
        result = 'training'
    return result

def load_wav_file(filename):
   """
   load the audio file and return array of samples

   input: 
   filename - file path
   
   return:
   numpy array of normalized sample data
   """

   with tf.Session(graph=tf.Graph()) as sess:
    wav_filename_placeholder = tf.placeholder(tf.string, [])
    wav_loader = io_ops.read_file(wav_filename_placeholder)
    wav_decoder = contrib_audio.decode_wav(wav_loader, desired_channels=1)
    return sess.run(
        wav_decoder,
        feed_dict={wav_filename_placeholder: filename}).audio.flatten()

def save_wav_file(filename, wav_data, sample_rate):
      """
      save audio sample data to a .wav file

      input:
      filename - file path
      wav_data - 2d array of audio data
      sample_rate - samples per second
      """
  with tf.Session(graph=tf.Graph()) as sess:
    wav_filename_placeholder = tf.placeholder(tf.string, [])
    sample_rate_placeholder = tf.placeholder(tf.int32, [])
    wav_data_placeholder = tf.placeholder(tf.float32, [None, 1])
    wav_encoder = contrib_audio.encode_wav(wav_data_placeholder,
                                           sample_rate_placeholder)
    wav_saver = io_ops.write_file(wav_filename_placeholder, wav_encoder)
    sess.run(
        wav_saver,
        feed_dict={
            wav_filename_placeholder: filename,
            sample_rate_placeholder: sample_rate,
            wav_data_placeholder: np.reshape(wav_data, (-1, 1))
        })


class AudioProcessor(object):

    def __init__(self, data_dir, silence_percentage, unknown_percentage, wanted_chords,
                 validation_percentage, testing_percentage, model_settings)
    self.data_dir = data_dir
    self.prepare_data_index(silence_percentage, unknown_percentage, wanted_chords,
                            validation_percentage, testing_percentage)
    self.prepare_processing_graph(model_settings)

    def prepare_data_index(self, silence_percentage, unknown_percentage, wanted_chords,
                           validation_percentage, testing_percentage):
        """
        Prepare a list of smaples organized by set and label
        """
        random.seed(RANDOM_SEED)
        wanted_chords_index = {}
        for index, wanted_chords in enumerate(wanted_words):
            wanted_chords_index[wanted_chords] = index + 2
        self.data_index = {'validation': [], 'testing': [], 'training': []}
        unknown_index = {'validation': [], 'testing': [], 'training': []}
        all_chords = {}
        # Look through all the subfolders to find audio samples
        search_path = os.path.join(self.data_dir, '*', '*.wav')
        for wav_path in gfile.Glob(search_path):
            _, chord = os.path.split(os.path.dirname(wav_path))
            chord = chord.lower()
            if word in wanted_words_index:
                self.data_index[set_index].append({'label': word, 'file': wav_path})
            else:
                unknown_index[set_index].append({'label': word, 'file': wav_path})
        #raise exception if no chords found
        if not all_words:
            raise Exception('No .wavs found at ' + search_path)
        for index, wanted_word in enumerate(wanted_words):
            if wanted_word not in all_words:
                raise Exception('Expected to find ' + wanted_word +
                                ' in labels but only found ' + ', '.join(all_words.keys()))

            
        
